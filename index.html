<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CKB Node Monitor</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --bg:      #0d0f14;
      --surface: #161a22;
      --border:  #252b38;
      --accent:  #3bc67a;
      --accent2: #4a9eff;
      --warn:    #f5a623;
      --danger:  #e74c3c;
      --text:    #e2e8f0;
      --muted:   #64748b;
      --card-bg: #1a202e;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
      font-size: 13px;
      min-height: 100vh;
    }

    header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 16px 24px; border-bottom: 1px solid var(--border);
      background: var(--surface);
    }
    .header-left { display: flex; align-items: center; gap: 12px; }
    .logo { font-size: 20px; font-weight: 700; letter-spacing: -0.5px; color: var(--accent); }
    .logo span { color: var(--text); }
    .chain-badge {
      background: #1a2e1f; color: var(--accent);
      border: 1px solid var(--accent);
      padding: 2px 10px; border-radius: 100px;
      font-size: 11px; font-weight: 600;
      text-transform: uppercase; letter-spacing: 1px;
    }
    .status-dot {
      width: 8px; height: 8px; border-radius: 50%;
      background: var(--muted); display: inline-block;
      margin-right: 6px; transition: background 0.3s;
    }
    .status-dot.ok    { background: var(--accent); box-shadow: 0 0 6px var(--accent); animation: pulse 2s infinite; }
    .status-dot.error { background: var(--danger); }
    @keyframes pulse { 0%,100%{opacity:1}50%{opacity:.5} }
    .status-text { color: var(--muted); font-size: 12px; }

    main { padding: 20px 24px; display: flex; flex-direction: column; gap: 20px; }

    /* ── Stats grid ── */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 12px;
    }
    .stat-card {
      background: var(--card-bg); border: 1px solid var(--border);
      border-radius: 10px; padding: 16px;
      position: relative; overflow: hidden;
    }
    .stat-card::before {
      content: ''; position: absolute; top: 0; left: 0; right: 0; height: 2px;
      background: var(--accent); opacity: .5;
    }
    .stat-card.c2::before { background: var(--accent2); }
    .stat-card.cw::before { background: var(--warn); }
    .stat-card.cm::before { background: var(--muted); }
    .stat-card.cp::before { background: #b44eff; }
    .stat-label {
      font-size: 10px; text-transform: uppercase;
      letter-spacing: 1.2px; color: var(--muted); margin-bottom: 8px;
    }
    .stat-value {
      font-size: 26px; font-weight: 700; color: var(--text);
      line-height: 1; transition: color .3s;
    }
    .stat-value.flash { color: var(--accent) !important; }
    .stat-sub { margin-top: 6px; font-size: 11px; color: var(--muted); }
    .stat-value.small { font-size: 18px; padding-top: 4px; }

    /* ── Epoch ── */
    .epoch-card {
      background: var(--card-bg); border: 1px solid var(--border);
      border-radius: 10px; padding: 16px 20px;
    }
    .epoch-header { display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 10px; }
    .epoch-title { font-size: 10px; text-transform: uppercase; letter-spacing: 1.2px; color: var(--muted); }
    .epoch-nums  { font-size: 13px; color: var(--text); }
    .epoch-nums .em { color: var(--accent2); font-weight: 600; }
    .track { width: 100%; height: 6px; background: var(--border); border-radius: 3px; overflow: hidden; }
    .fill  { height: 100%; background: linear-gradient(90deg, var(--accent2), var(--accent)); border-radius: 3px; transition: width .8s ease; }

    /* ── Two-col layout ── */
    .two-col { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 700px) { .two-col { grid-template-columns: 1fr; } }

    /* ── Three-col charts ── */
    .chart-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
    }
    @media (max-width: 900px) { .chart-grid { grid-template-columns: 1fr; } }

    /* ── Panels ── */
    .panel { background: var(--card-bg); border: 1px solid var(--border); border-radius: 10px; overflow: hidden; }
    .panel-header {
      display: flex; justify-content: space-between; align-items: center;
      padding: 10px 16px; border-bottom: 1px solid var(--border);
      background: var(--surface);
    }
    .panel-title { font-size: 10px; text-transform: uppercase; letter-spacing: 1px; color: var(--muted); }
    .panel-badge { font-size: 10px; background: var(--border); color: var(--muted); padding: 2px 8px; border-radius: 100px; }

    .chart-panel {
      background: var(--card-bg); border: 1px solid var(--border);
      border-radius: 10px; overflow: hidden;
    }
    .chart-panel .panel-header { background: var(--surface); }
    .chart-body { padding: 12px 14px 10px; position: relative; height: 190px; }

    /* ── Scrollable lists ── */
    .scroll-list { max-height: 260px; overflow-y: auto; }
    .scroll-list::-webkit-scrollbar { width: 4px; }
    .scroll-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

    .block-row {
      display: grid; grid-template-columns: 100px 1fr 70px 70px;
      gap: 8px; padding: 8px 16px;
      border-bottom: 1px solid var(--border);
      align-items: center; transition: background .15s;
    }
    .block-row:last-child { border-bottom: none; }
    .block-row:hover { background: rgba(255,255,255,.02); }
    .block-row.new-block { animation: newb 1.2s ease-out; }
    @keyframes newb { from { background: rgba(59,198,122,.15); } to { background: transparent; } }
    .bnum  { color: var(--accent); font-weight: 600; }
    .bhash { color: var(--muted); font-size: 11px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .btxs  { color: var(--text); font-size: 12px; text-align: right; }
    .bage  { color: var(--muted); font-size: 11px; text-align: right; }

    .kv-row { display: flex; justify-content: space-between; padding: 9px 16px; border-bottom: 1px solid var(--border); align-items: center; }
    .kv-row:last-child { border-bottom: none; }
    .kv-k { color: var(--muted); font-size: 12px; }
    .kv-v { font-weight: 600; }
    .kv-v.g { color: var(--accent); }
    .kv-v.w { color: var(--warn); }

    .peer-row {
      display: grid; grid-template-columns: 1fr 80px;
      gap: 8px; padding: 7px 16px;
      border-bottom: 1px solid var(--border); font-size: 11px; align-items: center;
    }
    .peer-row:last-child { border-bottom: none; }
    .paddr { color: var(--muted); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .psync { text-align: right; }
    .sok   { color: var(--accent); }
    .sbeh  { color: var(--warn); }

    .miner-row {
      display: grid; grid-template-columns: 60px 1fr 80px 70px 70px;
      gap: 8px; padding: 7px 16px;
      border-bottom: 1px solid var(--border); font-size: 11px; align-items: center;
    }
    .miner-row:last-child { border-bottom: none; }
    .miner-row:hover { background: rgba(255,255,255,.02); }
    .miner-id  { color: var(--accent); font-weight: 600; }
    .miner-addr{ color: var(--muted); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .miner-diff{ color: var(--accent2); text-align: right; }
    .miner-sh  { color: var(--text); text-align: right; }
    .miner-up  { color: var(--muted); text-align: right; }

    .mining-status-dot {
      display: inline-block; width: 7px; height: 7px;
      border-radius: 50%; margin-right: 5px; background: var(--muted);
    }
    .mining-status-dot.active { background: var(--accent); box-shadow: 0 0 6px var(--accent); animation: pulse 2s infinite; }
    .mining-status-dot.offline { background: var(--danger); }

    .stat-card.csolo::before { background: #f5a623; }
      color: var(--muted); font-size: 11px;
      border-top: 1px solid var(--border);
    }

    #overlay {
      position: fixed; inset: 0;
      background: rgba(13,15,20,.92);
      display: flex; align-items: center; justify-content: center;
      z-index: 100; flex-direction: column; gap: 16px;
    }
    #overlay.gone { display: none; }
    .spinner {
      width: 32px; height: 32px;
      border: 3px solid var(--border); border-top-color: var(--accent);
      border-radius: 50%; animation: spin .8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .ov-text { color: var(--muted); font-size: 13px; }
  </style>
</head>
<body>

<div id="overlay">
  <div class="spinner"></div>
  <div class="ov-text" id="ov-msg">Loading node data…</div>
</div>

<header>
  <div class="header-left">
    <div class="logo">CKB<span> Node</span></div>
    <div class="chain-badge" id="chain-badge">Mainnet</div>
  </div>
  <div>
    <span class="status-dot" id="sdot"></span>
    <span class="status-text" id="stxt">Connecting…</span>
  </div>
</header>

<main>

  <!-- Stats row -->
  <div class="stats-grid">
    <div class="stat-card">
      <div class="stat-label">Block Height</div>
      <div class="stat-value" id="s-height">—</div>
      <div class="stat-sub" id="s-blocktime">—</div>
    </div>
    <div class="stat-card c2">
      <div class="stat-label">Epoch</div>
      <div class="stat-value" id="s-epoch">—</div>
      <div class="stat-sub" id="s-epochsub">—</div>
    </div>
    <div class="stat-card cw">
      <div class="stat-label">Peers</div>
      <div class="stat-value" id="s-peers">—</div>
      <div class="stat-sub">connected</div>
    </div>
    <div class="stat-card cm">
      <div class="stat-label">Mempool</div>
      <div class="stat-value" id="s-pending">—</div>
      <div class="stat-sub">pending txs</div>
    </div>
    <div class="stat-card cm">
      <div class="stat-label">Avg Block Time</div>
      <div class="stat-value small" id="s-interval">—</div>
      <div class="stat-sub">last 20 blocks</div>
    </div>
    <div class="stat-card cp">
      <div class="stat-label">Network Hashrate</div>
      <div class="stat-value small" id="s-hashrate">—</div>
      <div class="stat-sub">est. current</div>
    </div>
  </div>

  <!-- Epoch progress -->
  <div class="epoch-card">
    <div class="epoch-header">
      <div class="epoch-title">Epoch Progress</div>
      <div class="epoch-nums" id="epoch-label">—</div>
    </div>
    <div class="track"><div class="fill" id="epoch-bar" style="width:0%"></div></div>
  </div>

  <!-- Charts row -->
  <div class="chart-grid">
    <div class="chart-panel">
      <div class="panel-header">
        <div class="panel-title">Block Time · last 60 blocks</div>
        <div class="panel-badge" id="bt-avg-badge">avg —s</div>
      </div>
      <div class="chart-body"><canvas id="chart-blocktime"></canvas></div>
    </div>
    <div class="chart-panel">
      <div class="panel-header">
        <div class="panel-title">TX per Block · last 30 blocks</div>
        <div class="panel-badge" id="tx-avg-badge">avg —</div>
      </div>
      <div class="chart-body"><canvas id="chart-txperblock"></canvas></div>
    </div>
    <div class="chart-panel">
      <div class="panel-header">
        <div class="panel-title">Network Hashrate · est. TH/s</div>
        <div class="panel-badge" id="hr-cur-badge">—</div>
      </div>
      <div class="chart-body"><canvas id="chart-hashrate"></canvas></div>
    </div>
  </div>

  <!-- Block list + side panels -->
  <div class="two-col">
    <div class="panel">
      <div class="panel-header">
        <div class="panel-title">Recent Blocks</div>
        <div class="panel-badge" id="block-badge">● live</div>
      </div>
      <div class="scroll-list" id="block-list">
        <div style="padding:20px;color:var(--muted);text-align:center">Loading…</div>
      </div>
    </div>

    <div style="display:flex;flex-direction:column;gap:12px">
      <div class="panel">
        <div class="panel-header"><div class="panel-title">TX Pool</div></div>
        <div class="kv-row"><span class="kv-k">Pending</span><span class="kv-v g" id="p-pending">—</span></div>
        <div class="kv-row"><span class="kv-k">Proposed</span><span class="kv-v" id="p-proposed">—</span></div>
        <div class="kv-row"><span class="kv-k">Orphan</span><span class="kv-v" id="p-orphan">—</span></div>
        <div class="kv-row"><span class="kv-k">Total size</span><span class="kv-v" id="p-size">—</span></div>
        <div class="kv-row"><span class="kv-k">Min fee rate</span><span class="kv-v" id="p-fee">—</span></div>
      </div>

      <div class="panel">
        <div class="panel-header">
          <div class="panel-title">Peers</div>
          <div class="panel-badge" id="peer-badge">0</div>
        </div>
        <div class="scroll-list" style="max-height:200px" id="peer-list">
          <div style="padding:16px;color:var(--muted);text-align:center">Loading…</div>
        </div>
      </div>
    </div>
  </div>

  <!-- ── Solo Mining Section ── -->
  <div style="border-top:1px solid var(--border);padding-top:4px">
    <div style="font-size:10px;text-transform:uppercase;letter-spacing:1.2px;color:var(--muted);padding:0 0 12px 2px">
      <span class="mining-status-dot" id="mine-dot"></span>Solo Mining · Direct Node
    </div>
  </div>

  <!-- Mining stat cards -->
  <div class="stats-grid">
    <div class="stat-card csolo">
      <div class="stat-label">Current Job</div>
      <div class="stat-value small" id="mine-height">—</div>
      <div class="stat-sub" id="mine-epoch">—</div>
    </div>
    <div class="stat-card csolo">
      <div class="stat-label">Miners Connected</div>
      <div class="stat-value" id="mine-count">—</div>
      <div class="stat-sub">active connections</div>
    </div>
    <div class="stat-card csolo">
      <div class="stat-label">Total Hashrate</div>
      <div class="stat-value small" id="mine-hashrate">—</div>
      <div class="stat-sub">estimated from shares</div>
    </div>
    <div class="stat-card csolo">
      <div class="stat-label">Shares Accepted</div>
      <div class="stat-value" id="mine-accepted">—</div>
      <div class="stat-sub" id="mine-sharerates">submitted / rejected</div>
    </div>
    <div class="stat-card csolo">
      <div class="stat-label">Blocks Found</div>
      <div class="stat-value" id="mine-blocks">—</div>
      <div class="stat-sub" id="mine-uptime">—</div>
    </div>
    <div class="stat-card csolo">
      <div class="stat-label">Proxy Status</div>
      <div class="stat-value small" id="mine-status">—</div>
      <div class="stat-sub" id="mine-node">—</div>
    </div>
  </div>

  <!-- Miner list -->
  <div class="panel">
    <div class="panel-header">
      <div class="panel-title">Connected Miners</div>
      <div class="panel-badge" id="mine-badge">0</div>
    </div>
    <div style="display:grid;grid-template-columns:60px 1fr 80px 80px 70px 70px;gap:8px;padding:6px 16px;border-bottom:1px solid var(--border);font-size:10px;color:var(--muted);text-transform:uppercase;letter-spacing:.8px">
      <span>ID</span><span>Address</span><span style="text-align:right">Hashrate</span><span style="text-align:right">Difficulty</span><span style="text-align:right">Shares</span><span style="text-align:right">Uptime</span>
    </div>
    <div class="scroll-list" style="max-height:220px" id="miner-list">
      <div style="padding:16px;color:var(--muted);text-align:center">Loading…</div>
    </div>
  </div>

</main>
<footer>CKB Node Monitor · node 192.168.68.87 · polling every 5s</footer>

<script>
  const RPC = '/rpc';
  let reqId = 1;
  let lastHeight = null;
  let recentBlocks = [];
  let blockTimestamps = [];
  let pollFails = 0;

  // ── Chart instances ───────────────────────────────────────────────────────
  let btChart  = null;   // block time
  let txChart  = null;   // tx per block
  let hrChart  = null;   // hashrate

  const CHART_OPTS_BASE = {
    responsive: true,
    maintainAspectRatio: false,
    animation: { duration: 400 },
    plugins: {
      legend: { display: false },
      tooltip: {
        backgroundColor: '#1a202e',
        borderColor: '#252b38',
        borderWidth: 1,
        titleColor: '#64748b',
        bodyColor: '#e2e8f0',
      },
    },
    scales: {
      x: {
        display: false,
        grid: { color: '#252b38' },
      },
      y: {
        display: true,
        grid: { color: '#1e2535' },
        ticks: { color: '#64748b', font: { size: 10 } },
        border: { color: '#252b38' },
      },
    },
  };

  function mkLineChart(ctx, color, yLabel) {
    return new Chart(ctx, {
      type: 'line',
      data: { labels: [], datasets: [{ data: [], borderColor: color, backgroundColor: color + '18', borderWidth: 2, pointRadius: 0, pointHoverRadius: 3, fill: true, tension: 0.3 }] },
      options: {
        ...CHART_OPTS_BASE,
        scales: {
          ...CHART_OPTS_BASE.scales,
          y: { ...CHART_OPTS_BASE.scales.y, title: { display: false } },
        },
      },
    });
  }

  function mkBarChart(ctx, color) {
    return new Chart(ctx, {
      type: 'bar',
      data: { labels: [], datasets: [{ data: [], backgroundColor: color + '99', borderColor: color, borderWidth: 1, borderRadius: 2 }] },
      options: {
        ...CHART_OPTS_BASE,
        scales: {
          ...CHART_OPTS_BASE.scales,
          y: { ...CHART_OPTS_BASE.scales.y, beginAtZero: true },
        },
      },
    });
  }

  function initCharts() {
    btChart = mkLineChart(document.getElementById('chart-blocktime').getContext('2d'), '#3bc67a');
    txChart = mkBarChart(document.getElementById('chart-txperblock').getContext('2d'), '#4a9eff');
    hrChart = mkLineChart(document.getElementById('chart-hashrate').getContext('2d'), '#b44eff');
  }

  // ── RPC ───────────────────────────────────────────────────────────────────
  async function rpc(method, params = []) {
    const r = await fetch(RPC, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ jsonrpc: '2.0', id: reqId++, method, params }),
    });
    const j = await r.json();
    if (j.error) throw new Error(j.error.message);
    return j.result;
  }

  // ── History fetch ─────────────────────────────────────────────────────────
  async function fetchHistory() {
    const r = await fetch('/history');
    if (!r.ok) throw new Error('history ' + r.status);
    return r.json();
  }

  // ── Update charts from history ────────────────────────────────────────────
  function updateCharts(hist) {
    const blocks = hist.blocks || [];

    // Block time chart (all 60)
    const btData = blocks.map(b => ({ x: '#' + b.number, y: +(b.blockTime / 1000).toFixed(2) }));
    btChart.data.labels   = btData.map(d => d.x);
    btChart.data.datasets[0].data = btData.map(d => d.y);
    btChart.update('none');

    // Avg badge
    const avgBt = btData.length ? (btData.reduce((s, d) => s + d.y, 0) / btData.length).toFixed(1) : '—';
    document.getElementById('bt-avg-badge').textContent = 'avg ' + avgBt + 's';

    // TX per block chart (last 30 that have tx data)
    const txBlocks = blocks.filter(b => b.txCount !== null).slice(-30);
    const txData   = txBlocks.map(b => ({ x: '#' + b.number, y: b.txCount }));
    txChart.data.labels   = txData.map(d => d.x);
    txChart.data.datasets[0].data = txData.map(d => d.y);
    txChart.update('none');

    const avgTx = txData.length ? (txData.reduce((s, d) => s + d.y, 0) / txData.length).toFixed(1) : '—';
    document.getElementById('tx-avg-badge').textContent = 'avg ' + avgTx;

    // Hashrate chart
    const hrData = (hist.hashratePerBlock || []).map(h => ({ x: '#' + h.number, y: +(h.hashrate).toFixed(1) }));
    hrChart.data.labels   = hrData.map(d => d.x);
    hrChart.data.datasets[0].data = hrData.map(d => d.y);
    hrChart.update('none');

    const latestHr = hrData.length ? hrData[hrData.length - 1].y : '—';
    document.getElementById('hr-cur-badge').textContent = latestHr + (latestHr !== '—' ? ' TH/s' : '');

    // Top-level hashrate stat card
    document.getElementById('s-hashrate').textContent = hist.networkHashrate || '—';
  }

  // ── Formatting ────────────────────────────────────────────────────────────
  const hex = h => parseInt(h, 16);
  const fmt = n => n.toLocaleString();

  function parseEpoch(h) {
    const v = BigInt(h);
    return { number: Number(v & 0x00FFFFFFn), index: Number((v >> 24n) & 0xFFFFn), length: Number((v >> 40n) & 0xFFFFn) };
  }

  function timeAgo(ts) {
    const s = Math.floor((Date.now() - ts) / 1000);
    if (s < 2)   return 'just now';
    if (s < 60)  return s + 's ago';
    if (s < 120) return '1m ago';
    return Math.floor(s / 60) + 'm ago';
  }

  function fmtBytes(n) {
    if (n >= 1048576) return (n / 1048576).toFixed(1) + ' MB';
    if (n >= 1024)    return (n / 1024).toFixed(1) + ' KB';
    return n + ' B';
  }

  function shortHash(h) { return h.slice(0, 10) + '…' + h.slice(-6); }

  // ── Status bar ────────────────────────────────────────────────────────────
  function setStatus(state, text) {
    document.getElementById('sdot').className   = 'status-dot ' + state;
    document.getElementById('stxt').textContent = text;
  }

  function flash(id) {
    const el = document.getElementById(id);
    el.classList.remove('flash'); void el.offsetWidth; el.classList.add('flash');
    setTimeout(() => el.classList.remove('flash'), 800);
  }

  // ── Block list ────────────────────────────────────────────────────────────
  function renderBlocks() {
    document.getElementById('block-list').innerHTML = recentBlocks.map((b, i) => `
      <div class="block-row${i === 0 && b.isNew ? ' new-block' : ''}">
        <div class="bnum">#${fmt(b.number)}</div>
        <div class="bhash" title="${b.hash}">${shortHash(b.hash)}</div>
        <div class="btxs">${b.txs !== null ? b.txs + ' tx' : '—'}</div>
        <div class="bage">${timeAgo(b.timestamp)}</div>
      </div>
    `).join('');
  }

  async function loadInitialBlocks(tipNum) {
    const start = Math.max(0, tipNum - 9);
    const results = await Promise.all(
      Array.from({ length: tipNum - start + 1 }, (_, i) =>
        rpc('get_header_by_number', ['0x' + (start + i).toString(16)])
      )
    );
    recentBlocks = results.reverse().filter(Boolean).map(h => ({
      number: hex(h.number), hash: h.hash, timestamp: hex(h.timestamp), txs: null, isNew: false,
    }));
    blockTimestamps = recentBlocks.map(b => b.timestamp).reverse();
    renderBlocks();
  }

  function updateEpoch(epochHex) {
    const e = parseEpoch(epochHex);
    document.getElementById('s-epoch').textContent    = fmt(e.number);
    document.getElementById('s-epochsub').textContent = `block ${fmt(e.index)} of ${fmt(e.length)}`;
    const pct = e.length > 0 ? ((e.index / e.length) * 100).toFixed(1) : 0;
    document.getElementById('epoch-bar').style.width  = pct + '%';
    document.getElementById('epoch-label').innerHTML  =
      `Epoch <span class="em">#${fmt(e.number)}</span> &nbsp;·&nbsp; ` +
      `${fmt(e.index)} / ${fmt(e.length)} &nbsp;·&nbsp; <span class="em">${pct}%</span>`;
  }

  function updateAvgInterval() {
    if (blockTimestamps.length < 2) return;
    const diffs = [];
    for (let i = 1; i < blockTimestamps.length; i++) diffs.push(blockTimestamps[i] - blockTimestamps[i - 1]);
    const avg = diffs.reduce((a, b) => a + b, 0) / diffs.length;
    document.getElementById('s-interval').textContent = (avg / 1000).toFixed(1) + 's';
  }

  // ── Main poll: tip ────────────────────────────────────────────────────────
  async function pollTip() {
    const header = await rpc('get_tip_header');
    const height = hex(header.number);
    if (height !== lastHeight) {
      const isFirst = lastHeight === null;
      if (!isFirst) {
        const newBlock = { number: height, hash: header.hash, timestamp: hex(header.timestamp), txs: null, isNew: true };
        recentBlocks.unshift(newBlock);
        if (recentBlocks.length > 20) recentBlocks.pop();
        blockTimestamps.push(hex(header.timestamp));
        if (blockTimestamps.length > 10) blockTimestamps.shift();
        flash('s-height');
        setTimeout(() => { if (recentBlocks[0]) recentBlocks[0].isNew = false; }, 1500);
      }
      lastHeight = height;
      document.getElementById('s-height').textContent    = fmt(height);
      document.getElementById('s-blocktime').textContent = 'at ' + new Date(hex(header.timestamp)).toLocaleTimeString();
      updateEpoch(header.epoch);
      updateAvgInterval();
      renderBlocks();
      if (isFirst) await loadInitialBlocks(height);
    }
  }

  // ── Slow poll: peers + pool (every 30s) ───────────────────────────────────
  async function pollExtras() {
    const [peers, pool] = await Promise.all([rpc('get_peers'), rpc('tx_pool_info')]);
    const pc = peers.length;
    document.getElementById('s-peers').textContent     = pc;
    document.getElementById('peer-badge').textContent  = pc;

    const peerList = document.getElementById('peer-list');
    peerList.innerHTML = peers.length === 0
      ? '<div style="padding:16px;color:var(--muted);text-align:center">No peers</div>'
      : peers.map(p => {
          const raw  = p.addresses?.[0]?.address ?? '';
          const ip   = raw.replace(/\/p2p\/.+$/, '').replace(/^\/ip[46]\//, '').replace(/\/tcp\/(\d+)$/, ':$1');
          const sync = p.sync_state;
          const diff = sync ? hex(sync.best_known_header_number) - hex(sync.last_common_header_number) : 0;
          return `<div class="peer-row">
            <div class="paddr" title="${raw}">${ip || raw.slice(0, 30)}</div>
            <div class="psync ${diff > 5 ? 'sbeh' : 'sok'}">${diff > 5 ? diff + ' behind' : 'synced'}</div>
          </div>`;
        }).join('');

    const pend = hex(pool.pending);
    document.getElementById('p-pending').textContent  = pend;
    document.getElementById('p-pending').className    = 'kv-v ' + (pend > 20 ? 'w' : 'g');
    document.getElementById('p-proposed').textContent = hex(pool.proposed);
    document.getElementById('p-orphan').textContent   = hex(pool.orphan);
    document.getElementById('p-size').textContent     = fmtBytes(hex(pool.total_tx_size));
    document.getElementById('p-fee').textContent      = hex(pool.min_fee_rate) + ' shan/kB';
    document.getElementById('s-pending').textContent  = pend;
  }

  // ── History poll (every 60s) ──────────────────────────────────────────────
  async function pollHistory() {
    try {
      const hist = await fetchHistory();
      updateCharts(hist);
    } catch(e) {
      console.warn('history fetch failed:', e.message);
    }
  }

  // ── Boot ──────────────────────────────────────────────────────────────────
  async function init() {
    initCharts();
    try {
      await pollTip();
      await Promise.all([pollExtras(), pollHistory()]);
      setStatus('ok', 'Connected · 192.168.68.87');
      document.getElementById('overlay').classList.add('gone');
      pollFails = 0;
    } catch(e) {
      pollFails++;
      document.getElementById('ov-msg').textContent = 'Cannot reach node — retrying…';
      setStatus('error', 'Connection failed');
      console.error(e);
    }
  }

  async function tipLoop() {
    try {
      await pollTip();
      if (pollFails > 0) {
        pollFails = 0;
        setStatus('ok', 'Connected · 192.168.68.87');
        document.getElementById('overlay').classList.add('gone');
      }
    } catch(e) {
      if (++pollFails >= 3) {
        setStatus('error', 'Node unreachable');
        document.getElementById('overlay').classList.remove('gone');
        document.getElementById('ov-msg').textContent = 'Lost connection — retrying…';
      }
    }
  }

  // ── Solo Mining Poll ──────────────────────────────────────────────────────
  function fmtUptime(sec) {
    if (sec < 60)  return sec + 's';
    if (sec < 3600) return Math.floor(sec/60) + 'm ' + (sec%60) + 's';
    return Math.floor(sec/3600) + 'h ' + Math.floor((sec%3600)/60) + 'm';
  }

  function parseEpochHex(h) {
    // epoch hex: 0x00LLLLLLNNNNNNEE where LL=length, NN=index, EE=epoch
    const n = BigInt(h);
    const epoch  = Number(n & 0xFFFFFFn);
    const index  = Number((n >> 24n) & 0xFFFFFFn);
    const length = Number((n >> 48n) & 0xFFFFn);
    return `Epoch ${epoch} · ${index}/${length}`;
  }

  async function pollMining() {
    try {
      const r = await fetch('/mining');
      const d = await r.json();

      const dot = document.getElementById('mine-dot');
      if (d.status === 'offline' || d.error) {
        dot.className = 'mining-status-dot offline';
        document.getElementById('mine-status').textContent = 'Offline';
        document.getElementById('mine-count').textContent = '0';
        return;
      }

      dot.className = 'mining-status-dot active';

      // Status cards
      document.getElementById('mine-status').textContent = d.status || '—';
      document.getElementById('mine-node').textContent   =
        (d.nodeHealthy === false ? '⚠ NODE OFFLINE — ' : '') + (d.node || '—');
      if (d.nodeHealthy === false) {
        document.getElementById('mine-node').style.color = 'var(--danger)';
      } else {
        document.getElementById('mine-node').style.color = '';
      }
      document.getElementById('mine-height').textContent = d.block?.height?.toLocaleString() ?? '—';
      document.getElementById('mine-epoch').textContent  = d.block?.epoch ? parseEpochHex(d.block.epoch) : '—';
      document.getElementById('mine-count').textContent  = d.miners?.count ?? '0';
      document.getElementById('mine-blocks').textContent = d.totals?.blocksFound ?? '0';
      document.getElementById('mine-uptime').textContent = d.uptime ?? '—';
      document.getElementById('mine-accepted').textContent = d.totals?.sharesAccepted ?? '0';
      document.getElementById('mine-hashrate').textContent = d.hashrate ?? '—';
      document.getElementById('mine-sharerates').textContent =
        `${d.totals?.sharesSubmitted ?? 0} submitted · ${d.totals?.sharesRejected ?? 0} rejected`;

      // Miner list
      const badge = document.getElementById('mine-badge');
      const list  = document.getElementById('miner-list');
      const miners = d.miners?.list ?? [];
      badge.textContent = miners.length;

      if (miners.length === 0) {
        list.innerHTML = '<div style="padding:16px;color:var(--muted);text-align:center">No miners connected</div>';
        return;
      }

      // Group by IP address — NerdMiner opens many connections
      const byAddr = {};
      miners.forEach(m => {
        const k = m.address || 'unknown';
        if (!byAddr[k]) byAddr[k] = { conns: 0, shares: 0, accepted: 0, rejected: 0, difficulty: m.difficulty, minUptime: m.uptimeSec, maxUptime: m.uptimeSec, worker: m.worker, hashrateHps: 0 };
        byAddr[k].conns++;
        byAddr[k].shares      += m.sharesSubmitted;
        byAddr[k].accepted    += m.sharesAccepted;
        byAddr[k].rejected    += m.sharesRejected;
        byAddr[k].hashrateHps += m.hashrateHps || 0;
        if (m.uptimeSec < byAddr[k].minUptime) byAddr[k].minUptime = m.uptimeSec;
        if (m.uptimeSec > byAddr[k].maxUptime) byAddr[k].maxUptime = m.uptimeSec;
      });

      // Format hashrate per group
      function fmtHr(hps) {
        if (hps >= 1e12) return (hps/1e12).toFixed(2)+' TH/s';
        if (hps >= 1e9)  return (hps/1e9).toFixed(2)+' GH/s';
        if (hps >= 1e6)  return (hps/1e6).toFixed(2)+' MH/s';
        if (hps >= 1e3)  return (hps/1e3).toFixed(2)+' kH/s';
        return hps.toFixed(0)+' H/s';
      }
      Object.values(byAddr).forEach(info => {
        info.hashrate = info.hashrateHps > 0 ? fmtHr(info.hashrateHps) : '—';
      });

      list.innerHTML = Object.entries(byAddr).map(([addr, info]) => `
        <div class="miner-row">
          <span class="miner-id">${info.conns}×</span>
          <span class="miner-addr">${addr}${info.worker && info.worker !== 'unknown' ? ' · ' + info.worker : ''}</span>
          <span class="miner-diff" style="color:var(--accent)">${info.hashrate || '—'}</span>
          <span class="miner-diff">${info.difficulty}</span>
          <span class="miner-sh">${info.accepted}/${info.shares}</span>
          <span class="miner-up">${fmtUptime(info.maxUptime)}</span>
        </div>`).join('');

    } catch(e) {
      document.getElementById('mine-dot').className = 'mining-status-dot offline';
      document.getElementById('mine-status').textContent = 'Error';
    }
  }

  // Refresh block age labels every 5s
  setInterval(renderBlocks, 5000);

  init().then(() => {
    setInterval(tipLoop,    5000);
    setInterval(pollExtras, 30000);
    setInterval(pollHistory, 60000);
    pollMining();
    setInterval(pollMining, 10000);
  });
</script>
</body>
</html>
