#!/usr/bin/env node
/**
 * CKB Node Dashboard — server.js
 * Serves the dashboard UI, proxies JSON-RPC calls to a CKB node,
 * and provides block history + hashrate data via /history.
 *
 * Config priority (highest → lowest):
 *   1. Environment variables: CKB_HOST, CKB_PORT, DASHBOARD_PORT
 *   2. config.json (generated by setup.sh)
 *   3. Built-in defaults (127.0.0.1:8114, port 8080)
 */

const http = require('http');
const fs   = require('fs');
const path = require('path');

// ── Crash guards — log and survive rather than die ────────────────────────────
process.on('uncaughtException', (err) => {
  console.error('[uncaughtException]', new Date().toISOString(), err.message);
  // Port conflict or bind error — can't recover, exit cleanly
  if (err.code === 'EADDRINUSE' || err.code === 'EACCES') {
    console.error('[fatal] Cannot bind port — exiting.');
    process.exit(1);
  }
});
process.on('unhandledRejection', (reason) => console.error('[unhandledRejection]', new Date().toISOString(), reason?.message ?? reason));

// ── Config ────────────────────────────────────────────────────────────────────
const CONFIG_PATH = path.join(__dirname, '..', 'config.json');
let fileConfig = {};
try { fileConfig = JSON.parse(fs.readFileSync(CONFIG_PATH, 'utf8')); } catch (_) {}

const PORT     = parseInt(process.env.DASHBOARD_PORT || fileConfig.dashboard_port || 8080, 10);
const CKB_HOST = process.env.CKB_HOST || fileConfig.node_host || '127.0.0.1';
const CKB_PORT = parseInt(process.env.CKB_PORT     || fileConfig.node_port     || 8114, 10);
const DIR      = path.join(__dirname, 'public');

// ── Internal CKB RPC helpers ──────────────────────────────────────────────────
let rpcId = 1;

const CKB_TIMEOUT_MS = 10000; // 10s — abort if CKB node hangs

function ckbRequest(bodyObj) {
  return new Promise((resolve, reject) => {
    const bodyStr = JSON.stringify(bodyObj);
    const req = http.request({
      hostname: CKB_HOST, port: CKB_PORT, path: '/', method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(bodyStr) },
      timeout: CKB_TIMEOUT_MS,
    }, (res) => {
      let data = '';
      res.on('data', d => { data += d; });
      res.on('end', () => { try { resolve(JSON.parse(data)); } catch(e) { reject(e); } });
    });
    req.on('timeout', () => { req.destroy(new Error('CKB node request timed out')); });
    req.on('error', reject);
    req.write(bodyStr);
    req.end();
  });
}

function rpcCall(method, params = []) {
  return ckbRequest({ jsonrpc: '2.0', id: rpcId++, method, params })
    .then(r => { if (r.error) throw new Error(r.error.message); return r.result; });
}

function rpcBatch(requests) {
  const batch = requests.map((r, i) => ({ jsonrpc: '2.0', id: i, method: r.method, params: r.params || [] }));
  return ckbRequest(batch).then(results => {
    if (!Array.isArray(results)) throw new Error('Expected batch array response');
    return results.sort((a, b) => a.id - b.id).map(r => r.result);
  });
}

// ── History cache ─────────────────────────────────────────────────────────────
let histCache     = null;
let histCacheTime = 0;
const HIST_TTL    = 15000;  // 15s cache
const HIST_COUNT  = 60;     // 60 blocks of header history
const TX_COUNT    = 30;     // last 30 blocks get full tx counts

function formatHashrate(h) {
  const units = [
    [10n ** 18n, 'EH/s'],
    [10n ** 15n, 'PH/s'],
    [10n ** 12n, 'TH/s'],
    [10n **  9n, 'GH/s'],
    [10n **  6n, 'MH/s'],
    [10n **  3n, 'kH/s'],
    [1n,          'H/s'],
  ];
  for (const [div, unit] of units) {
    if (h >= div) {
      const val = Number(h * 1000n / div) / 1000;
      return val.toFixed(2) + ' ' + unit;
    }
  }
  return String(h) + ' H/s';
}

async function buildHistory() {
  const now = Date.now();
  if (histCache && (now - histCacheTime) < HIST_TTL) return histCache;

  const [tipHeader, chainInfo] = await Promise.all([
    rpcCall('get_tip_header'),
    rpcCall('get_blockchain_info'),
  ]);

  const tipNum = parseInt(tipHeader.number, 16);
  const count  = Math.min(HIST_COUNT, tipNum + 1);
  const start  = tipNum - count + 1;

  // Batch-fetch headers for block time history
  const headers = await rpcBatch(
    Array.from({ length: count }, (_, i) => ({
      method: 'get_header_by_number',
      params: ['0x' + (start + i).toString(16)],
    }))
  );

  // Batch-fetch full blocks for tx counts (last TX_COUNT blocks)
  const txFetchCount = Math.min(TX_COUNT, count);
  const blocks = await rpcBatch(
    Array.from({ length: txFetchCount }, (_, i) => ({
      method: 'get_block_by_number',
      params: ['0x' + (tipNum - txFetchCount + 1 + i).toString(16)],
    }))
  );

  // Build tx count map: block_number → tx_count (excludes coinbase)
  const txMap = {};
  blocks.forEach(b => {
    if (b && b.header) {
      const n = parseInt(b.header.number, 16);
      txMap[n] = Math.max(0, (b.transactions?.length ?? 1) - 1);
    }
  });

  // Build per-block data (skip first — no previous timestamp to diff against)
  const blockData = [];
  for (let i = 1; i < headers.length; i++) {
    const h    = headers[i];
    const prev = headers[i - 1];
    if (!h || !prev) continue;
    const num       = parseInt(h.number, 16);
    const ts        = parseInt(h.timestamp, 16);
    const prevTs    = parseInt(prev.timestamp, 16);
    blockData.push({
      number:    num,
      timestamp: ts,
      txCount:   txMap[num] ?? null,
      blockTime: ts - prevTs,  // ms
    });
  }

  // Avg block time over last 20 blocks
  const recent = blockData.slice(-20);
  const avgMs  = recent.reduce((s, b) => s + b.blockTime, 0) / (recent.length || 1);
  const avgSec = avgMs / 1000;

  // Network hashrate = difficulty / avg_block_time
  let hashrateStr      = '—';
  let hashratePerBlock = [];
  try {
    const diff  = BigInt('0x' + chainInfo.difficulty.replace(/^0x/, ''));
    hashrateStr = formatHashrate(diff / BigInt(Math.max(1, Math.round(avgSec))));

    // Per-block hashrate estimate (rolling 10-block window)
    const window = 10;
    for (let i = window; i < blockData.length; i++) {
      const slice  = blockData.slice(i - window, i);
      const wAvgMs = slice.reduce((s, b) => s + b.blockTime, 0) / slice.length;
      const wAvgS  = wAvgMs / 1000;
      const wHr    = wAvgS > 0 ? diff / BigInt(Math.max(1, Math.round(wAvgS))) : 0n;
      hashratePerBlock.push({ number: blockData[i].number, hashrate: Number(wHr / 10n ** 12n) }); // TH/s
    }
  } catch(_) { /* BigInt unavailable — skip */ }

  histCache = {
    blocks: blockData, avgBlockTimeSec: avgSec.toFixed(2),
    networkHashrate: hashrateStr, hashratePerBlock, tipHeight: tipNum,
  };
  histCacheTime = now;
  return histCache;
}

// ── Proxy a single/batch RPC call to the CKB node ────────────────────────────
function proxyRpc(body, res) {
  const req = http.request({
    hostname: CKB_HOST, port: CKB_PORT, path: '/', method: 'POST',
    headers: { 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(body) },
    timeout: CKB_TIMEOUT_MS,
  }, (ckbRes) => {
    res.writeHead(200, { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*' });
    ckbRes.pipe(res);
  });
  req.on('timeout', () => {
    req.destroy();
    res.writeHead(504, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: { code: -32000, message: 'Node timeout' } }));
  });
  req.on('error', (e) => {
    res.writeHead(502, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: { code: -32000, message: `Node unreachable: ${e.message}` } }));
  });
  req.write(body);
  req.end();
}

// ── Static file server ────────────────────────────────────────────────────────
const MIME = {
  '.html': 'text/html; charset=utf-8',
  '.js':   'application/javascript',
  '.css':  'text/css',
  '.json': 'application/json',
  '.ico':  'image/x-icon',
  '.png':  'image/png',
};

function serveStatic(reqPath, res) {
  const rel      = reqPath === '/' ? 'index.html' : reqPath.replace(/^\//, '');
  const filePath = path.join(DIR, rel);
  if (!filePath.startsWith(DIR)) { res.writeHead(403); res.end('Forbidden'); return; }
  fs.readFile(filePath, (err, data) => {
    if (err) { res.writeHead(404); res.end('Not found'); return; }
    res.writeHead(200, { 'Content-Type': MIME[path.extname(filePath)] || 'application/octet-stream' });
    res.end(data);
  });
}

// ── Main server ───────────────────────────────────────────────────────────────
const server = http.createServer((req, res) => {
  if (req.method === 'OPTIONS') {
    res.writeHead(204, {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type',
    });
    res.end();
    return;
  }

  if (req.url === '/health' && req.method === 'GET') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ ok: true, uptime: Math.floor(process.uptime()) }));
    return;
  }

  if (req.url === '/history' && req.method === 'GET') {
    buildHistory()
      .then(data => {
        res.writeHead(200, { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*' });
        res.end(JSON.stringify(data));
      })
      .catch(e => {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: e.message }));
      });
    return;
  }

  if (req.url === '/rpc' && req.method === 'POST') {
    let body = '', bodySize = 0;
    const MAX_BODY = 64 * 1024; // 64 KB
    req.on('data', d => { bodySize += d.length; if (bodySize > MAX_BODY) { req.destroy(); return; } body += d; });
    req.on('end', () => proxyRpc(body, res));
    return;
  }

  serveStatic(req.url, res);
});

server.listen(PORT, '0.0.0.0', () => {
  console.log(`CKB Node Dashboard`);
  console.log(`  UI:       http://0.0.0.0:${PORT}`);
  console.log(`  Node RPC: http://${CKB_HOST}:${CKB_PORT}`);
  buildHistory().catch(e => console.warn('History pre-warm failed:', e.message));
});
